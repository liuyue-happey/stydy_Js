<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="./css/index.css">
    <title>Document</title>
</head>

<body>
    <p>变量的命名规则</p>
    <p>类型转换<span>(字符串=>数字 || 隐式转换)</span></p>
    <p>转换布尔类型的5种情况</p>
    <p>运算符</p>
    <p>一元运算符</p>
    <p>逻辑运算符</p>
    <p>关系运算符 <span>( 全等 和 相等运算不等于自身的情况 )</span></p>
    <p>赋值运算符</p>
    <p>分支结构<span>(布尔值的隐式转换)</span></p>
    <p>三元运算符</p>
    <p>switch语句</p>
    <p>while循环<span>(do while循环)</span></p>
    <p>for循环</p>
    <p>continue和break</p>
    <hr>
    <p><span>数组 (求平均值) (求最大值和最小值||位置) </span></p>
    <p><span>函数 ( 函数参数 )</span></p>
    <p><span>函数的返回值</span></p>
    <p><span>arguments</span></p>
    <p><span>声明函数的方式</span></p>
    <p>作用域链</p>
    <p>预解析</p>
</body>
<script>
    var aa1 = '我是刘月';
    //  转换false的五种情况  "" 0 null udf NaN;
    //一元运算符 + = * / += /= -= *=;
    let _false = false;
    let _null = null;
    let zero = 0;
    let udf = undefined;
    let _NaN = NaN;
    let _true = 'a';
    // 三元运算符
    let aa = _true ? true : false;
    // console.log(_true || _false);
    // || && !
    // == ===
    // if(_null){
    //     console.log('_false');
    // }else if(_null){
    //     console.log('_true');
    // }else{
    //     console.log(false)
    // }
    // 求平均值
    // let num = 0;
    // for (let i = 0; i < array.length; i++) {
    //     num += array[i];
    // }
    // num /= array.length;
    // console.log(num);
    let array = [21, 11, 1, 2, 3, 4, 6, 20, 8, 10, 6];
    // 求数组中最大值和最小值   索引;
    let MAX = array[0];
    let MIN = array[0];
    let MAXindex = 0;
    let MINindex = 0;
    // for (let i = 0; i < array.length; i++) {
    //     if (MAX < array[i]) {
    //         MAX = array[i];
    //         MAXindex = i;
    //     };
    //     if (MIN > array[i]) {
    //         MIN = array[i];
    //         MINindex = i;
    //     };rest
    // };
    // 实参  实际参数   调用的时候传递的参数
    // 形参  形式参数   函数定义的时候传递的参数
    function fun(...rest) {
        console.log('fun');
        // console.log(arguments);  //实参列表 代表所有的参数的一个集合   伪数组
        console.log(rest);  //rest 参数  实参列表   是一个真正的数组; 可以完全取代arguments 
        return
        // 如果后面跟有参数   函数返回的就是 后面携带的参数  如果后面没有携带参数;那么它返回的就是一个udf 
    };

    fun('刘月月', 18, '女');
    // console.log(fun('刘月月',18));
    // 没有定义函数名的函数就叫做匿名函数;
    let fun1 = function () {
        return 'fun1222';
    }
    console.log(fun1());
    //自调用函数; 自己调用自己
    (function () {
        console.log('我是自调用函数');
    })();
    function fun2() {
        function aa() { };
        // 函数体也会进行一次预解析;解析过程与全局作用域一样; 
        // 会先对变量进行提升  然后对函数变量提升;
        // 两次变量提升  第一次提升变量    第二次函数声明进行提升;
        // 变量提升  aa = udf;
        //函数提升  aa = function
        // 所以 不管var 声明的变量 是否在 同名函数之前或者之后;  预解析结果,都将等于所声明函数;
        // 局部变量: 函数体以内使用var let const function class  声明的变量都属于局部变量;只能在函数体以内进行访问;函数体意外访问不到;
        console.log('------------------------------');
        var aaa = '1';
        console.log('aaa', aaa);
        function aaa() { };
        bbb = 'bbb';
    }
    fun2();
    console.log('bbb', bbb);
    // var let const 的区别
    // var   存在变量提升 允许重复声明 
    // console.log(aa);
    // var aa = 'aa';
    // console.log(aa);
    // aa = 'bb';
    // console.log(aa);
    // let 不存在变量提升 存在暂时性死区 不允许重复声明 
    // let var1 = '刘月';
    // console.log(var1);

    // const 常量 不存在变量提升 存在暂时性死区  声明即赋值(不允许先声明后赋值) 不允许重复声明  不允许二次赋值
    // const const1 = '刘月';
    // console.log(const1);
    // const arr = [1,2,3];
    // arr[3] = 4;
    // arr = [];
    // console.log(arr)

    // Array    set;
    // for    for in   for of  map;
    let arr = [1, 2, 3, 4, 5];
    let arr1 = new Set([1, 2, 3, 4, 5, 6]);
    let obj = {
        name: '刘月',
        age: 18,
        sex: '女'
    }
    console.log(arr);
    // console.log(arr1);
    // 循环数组的时候  是索引
    // for (let i = 0; i < arr.length; i++) {
    //     console.log('arr[i]' + '=' + arr[i]);
    // }
    // 循环数组   每一项是字符串  改变了数组内部的type类型
    // for (let k in arr) {
    //     console.log(typeof k);
    //     console.log('k=', k);
    // }
    // 循环数组 并没有改变数组内部元素的类型
    // for (let j of arr) {
    //     console.log(typeof j)
    //     console.log('j=', j);
    // }
    // 循环数组 并没有改变数组内部元素的类型
    // let item = arr.map(h => {
    //     let aa;
    //     if(h % 3 == 1) aa = h;
    //     return  aa
    // })
    // 循环数组 并没有改变数组内部元素的类型
    // let aa = arr.forEach(q => {
    //     let aa;
    //     if(q % 3 == 0) aa = q;
    //     return  aa
    // });
    // console.log(item);

    for (let i in Object.entries(obj)) {

        console.log(i);

    }

</script>

</html>